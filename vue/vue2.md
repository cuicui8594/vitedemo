# vue基础

## vue简介

Vue是一套用于构建用户界面的渐进式JavaScript框架，由尤雨溪（Evan You）创建。以下是对Vue的详细介绍：

### 设计目标

Vue的设计目标是让开发变得简单和灵活，通过采用声明式编程范式，使开发者能够更容易地构建用户界面。Vue可以逐步集成到现有项目中，无需对项目进行大规模重构，也可以作为单页应用程序的完整解决方案。

### 核心特点

1. **轻量级**：Vue的核心库非常小，打包后的文件大小约为20~30KB，这使得它在加载速度和性能方面具有显著优势，尤其是在移动设备上。
2. **双向数据绑定**：Vue实现了双向数据绑定，使得数据和视图保持同步。当数据发生变化时，视图会自动更新，反之亦然。这大大简化了开发者的工作，尤其是在处理复杂的用户交互时。
3. **组件化开发**：Vue支持组件化开发，将页面拆分为多个独立的、可复用的组件。这种方式不仅提升了代码的可维护性，还使得开发者可以更好地管理项目中的复杂性。
4. **虚拟DOM**（声明式编码）：Vue采用虚拟DOM技术，通过对比虚拟DOM和真实DOM之间的差异，只更新那些真正变化的部分，从而提高了页面渲染性能。
5. **渐进式架构**：Vue的设计理念是渐进式，即可以根据项目的需求逐步引入更多的功能。这种设计使得Vue在各种项目中都能灵活应用。

### 生态系统

Vue不仅是一个框架，它还拥有丰富的生态系统，以下是一些常用的Vue生态系统工具和库：

1. **Vue Router**：Vue官方提供的路由管理库，主要用于开发单页应用。它允许开发者定义页面的路由规则，并通过路由切换来更新视图。
2. **Vuex**：Vue官方提供的状态管理库，主要用于管理应用的全局状态。它采用单向数据流的模式，将应用的状态集中管理，方便调试和维护。
3. **Vue CLI**：Vue官方提供的命令行工具，主要用于快速搭建Vue项目。它提供了丰富的脚手架模板和插件，方便开发者快速构建和配置项目。

### 应用场景

Vue.js广泛用于以下几种场景：

1. **单页面应用程序开发**：单页面应用程序（SPA）是一种现代的Web开发模式，它通过动态加载内容而不是重新加载整个页面来提供更流畅的用户体验。Vue.js通过Vue Router可以轻松地配置和管理应用程序中的页面和组件，非常适合用于SPA开发。
2. **响应式网页应用**：Vue的核心是响应式数据绑定，它可以将数据与视图进行绑定，当数据发生变化时，视图会自动更新。这使得Vue非常适合用于开发需要实时更新数据的响应式网页应用。
3. **小型项目**：Vue适合用于小型项目的开发，因为它学习曲线较低、上手快，而且可以与其他库和项目无缝集成，方便快速搭建原型或简单的应用。

### 版本迭代

Vue自发布以来，已经经历了多个版本的迭代，逐渐发展成为一个成熟的前端框架。目前，Vue共有三个大版本，分别是Vue1、Vue2和Vue3。其中，Vue1几乎被淘汰，不建议学习与使用；Vue2和Vue3目前被广泛应用，并且Vue3将会逐步替代Vue2。Vue3支持Vue2中绝大多数的API与特性，同时Vue3还新增了一些特有的功能，如组合式（Composition）API、多根节点组件等，并废弃了Vue2中的一些旧功能。

## vue使用指南

官网[Vue.js - 渐进式 JavaScript 框架 | Vue.js](https://cn.vuejs.org/)

## vue环境搭建

下载开发版本和生产版本的js文件，引入html中

解决问题1：下载扩展

解决问题2:

因为引入的开发版本，在vue启动时会有提示，手动修改值

vue.config下边的属性

[productionTip](https://v2.cn.vuejs.org/v2/api/#productionTip)

> 2.2.0 新增

- **类型**：`boolean`

- **默认值**：`true`

- **用法**：

  设置为 `false` 以阻止 vue 在启动时生成生产提示。

## 初始vue

## vue-模板语法

### 插值语法   指令语法

```
（

v-bind：`v-bind` 用于绑定 HTML 属性。简写为 `:`。

 v-model ：`v-model` 在表单控件元素上创建双向数据绑定。

v-on：`v-on` 用于监听 DOM 事件。简写为 `@`。

 v-for：列表渲染指令。

）
```

```
<!-- vue模板语法 
1.插值语法
    功能：用于解析标签内容
    写法：{{xxx}}，xxx是js表达式，且可以直接读取到data的所有数据
2.指令语法
    功能：用与解析标签（包括标签属性，绑定事件，标签体内容）
    例子：v-bind:href="xxx"或:href="xxx",xxx还是js表达式
    备注：vue中很多指令，都是v-？？？的形式
 -->
```

## 数据绑定

在 Vue.js 中，数据绑定是其核心功能之一，它允许你将数据与视图（HTML）进行双向绑定，从而实现数据变化时视图自动更新，以及视图变化时数据自动同步。Vue.js 提供了多种数据绑定的方式，主要包括：

```
<!-- 
数据绑定:
1.单向绑定（v-bind）：数据只能从data流向页面
2.双向绑定（v-model）：数据不仅能从data流向页面，也可以从页面流向data
备注：1.双向绑定一般都应用于表单元素上（如input select等）
      2.v-model:value可以简写为v-model 因为v-model默认收集的值就是value的值
-->
```

## el和data的两种写法

```
<!-- el和data的两种使用方法
  1.el的两种方法
   （1）new Vue时配置el属性
   （2）先创建Vue实例，然后通过vm.$mount(#root)指定el的值 
  2.data的两种写法
    (1)对象式
    (2)函数式
    选择：学到vue组件时必须用函数式
  3.一个原则:
    由vue管理的函数，一定不要写箭头函数，一旦写箭头函数，this指向不再是vue实例
-->
```

## MVVM模型

MVVM（Model-View-ViewModel）是一种软件设计模式，主要用于构建用户界面（UI）。在Vue.js中，MVVM模式被广泛应用，使得开发者能够更高效地管理和更新用户界面。以下是MVVM模型中各个部分的详细解释以及它们在Vue.js中的体现：

###  Model（模型）

**Model** 代表应用中的数据部分。它通常是JavaScript对象或数组，用于存储应用的状态或数据。在Vue.js中，数据通常定义在组件的 `data` 函数中，或者使用Vuex等状态管理库来管理全局状态。

###  View（视图）

**View** 是用户界面，即用户看到并与之交互的部分。在Vue.js中，视图通常是通过模板语法（如HTML模板）来定义的，并且这些模板可以直接嵌入到组件的JavaScript代码中。

###  ViewModel（视图模型）

**ViewModel** 是MVVM模式的核心，它作为Model和View之间的桥梁，负责处理两者的交互。ViewModel包含业务逻辑和视图逻辑，负责将Model中的数据绑定到View上，以及将用户的交互行为转化为对Model的更新。

在Vue.js中，ViewModel通常是通过组件的实例来表示的。Vue实例会监听数据的变化，并在数据变化时自动更新视图。同时，Vue实例也提供了方法来处理用户交互，从而更新数据。

```
<!--  
         观察发现
             1.data中所有属性，都出现在了vm身上
             2.vm身上所有的属性以及vue原型上所有的属性，在vue模板中都可以直接使用
-->

<body>
    <!-- view 视图 模板-->
```

## 数据代理

### object.define.property方法

`Object.defineProperty()` 方法是 JavaScript 中一个用于直接在对象上定义新属性或修改现有属性的方法。它可以控制属性的一些特定行为，比如是否可枚举（enumerable）、是否可配置（configurable）以及是否可写（writable）。

这个方法接受三个参数：

1. **obj**：要定义属性的对象。
2. **prop**：要定义或修改的属性的名称。
3. **descriptor**：属性描述符。这是一个对象，可以包含以下一些或全部属性：
   - **value**：属性的值。可以是任何有效的 JavaScript 值（数字、字符串、对象等）。
   - **writable**：布尔值，指定属性的值是否可以被修改。默认为 false。
   - **configurable**：布尔值，指定属性描述符是否可以被修改或者属性是否可以被删除。默认为 false。
   - **enumerable**：布尔值，指定属性是否可以在 for...in 循环和 Object.keys() 方法中被枚举。默认为 false。
   - **get**：一个给属性提供 getter 的方法，如果没有 setter 则属性为只读。
   - **set**：一个给属性提供 setter 的方法，如果没有 getter 则只写无效。

注意，`writable`、`configurable` 和 `enumerable` 属性的默认值都是 `false`，而 `value` 和 `writable` 是互斥的，即如果指定了 `value`，则 `writable` 会默认为 `false`，除非显式地将其设置为 `true`。同样，`get` 和 `set` 也是互斥的，不能同时指定 `value` 或 `writable` 和 `get` 或 `set`。


### 理解数据代理

在编程领域，数据代理通常指的是通过一个对象来代理对另一个对象中属性的操作（读/写）。具体来说，数据代理可以使用 `Object.defineProperty()` 方法，将某个对象的属性“代理”到另一个对象上，并为这些属性指定 getter 或 setter。这样，当对代理对象的属性进行读写操作时，实际上是在操作被代理对象的相应属性。

例如，在 Vue.js 框架中，数据代理被广泛应用于实现响应式数据绑定。Vue 实例的 `data` 对象中的属性会被“代理”到 Vue 实例自身上，这样可以直接通过 Vue 实例来访问或修改这些属性，并且当属性发生变化时，Vue 能够自动检测到并更新视图。

### vue中的数据代理

在Vue.js中，数据代理是一个重要的概念，它允许我们通过Vue实例的`data`对象来访问和操作组件中的状态。Vue.js使用了ES6的`Object.defineProperty`方法（或在Vue 3中使用了`Proxy`对象）来实现数据代理，使得我们可以使用`vm`实例来直接访问和修改`data`中的数据，而无需直接操作`data`对象本身。

#### 数据代理的原理

数据代理的核心在于在Vue实例（`vm`）和`data`对象之间建立了一层“代理”关系。当我们在`vm`上访问或修改一个属性时，实际上是在访问或修改`data`对象中的对应属性。这种机制使得我们可以更方便地管理和操作数据，同时也提高了代码的可读性和维护性。

#### 在Vue 2中的数据代理

在Vue 2中，Vue使用了`Object.defineProperty`方法来实现数据代理。这个方法允许我们定义或修改一个对象的属性，并指定该属性的getter和setter函数。Vue通过为`data`对象中的每个属性设置getter和setter函数，来拦截对属性的访问和修改操作。

例如：

#### 在Vue 3中的数据代理

在Vue 3中，Vue使用了`Proxy`对象来实现数据代理。`Proxy`是ES6中引入的一个新的内置对象，它允许我们创建一个对象的代理，从而可以定义基本操作（如属性查找、赋值、枚举、函数调用等）的默认行为。

Vue 3通过`Proxy`对象来拦截对Vue实例的访问和修改操作，并相应地更新`data`对象中的属性。这种方式相比`Object.defineProperty`提供了更好的性能和更灵活的数据监听机制。

例如（简化版）：

需要注意的是，上面的代码只是一个简化的示例，Vue 3内部的数据代理实现要复杂得多，包括了对嵌套对象的深度监听、依赖收集、响应式更新等高级功能。

#### 总结

数据代理是Vue.js中一个非常重要的概念，它使得我们可以更方便地访问和修改组件中的状态。在Vue 2中，Vue使用了`Object.defineProperty`方法来实现数据代理；而在Vue 3中，Vue则使用了`Proxy`对象来实现更强大和灵活的数据代理机制。无论是哪种方式，数据代理都大大提高了Vue.js的易用性和开发效率。

#### 实例：

```
<!-- 
            1.Vue中的数据代理
                 通过vue对象来代理data对象中属性的操作（读/写）
            2.vue中数据代理的好处
                 更加方便的操作data中的数据
            3.基本原理
                  通过objiect.defineProerty()把data对象所有属性加到vm上
                  为每一个添加到vm上的属性，都指定一个getter/setter
                  在getter/setter内部去操作（读/写）data中对应的属性
-->
```

实例化Vue对象后vm共做了两件事，数据收集（左）和数据代理（右）

下图_data中 数据劫持 作用是检测data中的属性值的变化，改变页面中的数据。

#### 对数组方法的包装

在 Vue 2.x 中，为了确保响应式系统的正常工作，Vue 对原始数组的一些方法进行了包装（也称为“劫持”或“重写”）。这意味着当这些被包装的方法被调用时，Vue 能够检测到数组的变化，并更新视图。

具体来说，Vue 包装了以下数组方法：

1. `push`
2. `pop`
3. `shift`
4. `unshift`
5. `splice`
6. `sort`
7. `reverse`

## 事件处理

在 Vue.js 中，事件处理是一个非常重要的功能，它允许你响应用户在界面上的操作，比如点击、输入、提交表单等。Vue 提供了一种简洁的方法来监听和处理 DOM 事件。以下是一些关于 Vue 事件处理的基本知识和示例。

### 基本用法

在 Vue 模板中，你可以使用 `v-on` 指令（或简写 `@`）来监听 DOM 事件。例如，监听一个按钮的点击事件：

在 Vue 实例中，你需要定义 `handleClick` 方法：

### 传递参数

你可以在事件处理函数中传递参数。例如，传递一个事件对象或一个自定义参数：

在 Vue 实例中，你可以这样定义 `handleClick` 方法：

### 修饰符

Vue 提供了一些事件修饰符，用于简化常见的事件处理场景。例如：

- `.stop`：调用 `event.stopPropagation()` 阻止事件冒泡。
- `.prevent`：调用 `event.preventDefault()` 阻止默认行为。
- `.capture`：添加事件侦听器时使用捕获模式。
- `.self`：只在事件是从该元素本身触发时才触发回调。
- `.once`：事件将只会触发一次。

### 按键修饰符

对于键盘事件，Vue 提供了一些按键修饰符，如 `.enter`、`.tab`、`.delete`、`.esc`、`.space`、`.up`、`.down`、`.left`、`.right` 等。你可以使用它们来监听特定的按键事件。Vue.js 的事件处理机制非常强大且灵活,通过 `v-on` 指令和修饰符,你可以轻松地监听和处理各种 DOM 事件。希望这些示例能帮助你更好地理解 Vue 的事件处理功能。 使用v-on:xxx或者@xxx绑定事件 xxx是事件名。事件的回顾需要配置在methods对象中，最终会在v上。methods中配置的函数，不能用箭头函数，否则this指向就不是vm了。methods中配置的函数，都是被Vue管理的函数，this指向都是vm或者组件实例对象。@click=“demo”和@clcik=“demo（$event）”效果一样 但是后者可以传参。

### 事件修饰符

Vue事件修饰符是Vue.js提供的一种用于优化事件处理的工具。这些修饰符通过添加到事件监听器上，来控制事件的传播行为、默认行为等，从而简化代码、增强可读性、避免常见错误。以下是对Vue事件修饰符的详细介绍。

#### 一、常用事件修饰符

##### stop

功能：停止事件冒泡。

使用场景：防止事件从子元素冒泡到父元素，避免触发上层元素的处理函数。

##### prevent

功能：阻止事件的默认行为。

使用场景：阻止浏览器对特定事件的预定义响应，如点击链接跳转页面、提交表单等。

##### capture

功能：在捕获阶段触发事件处理程序，而不是冒泡阶段。

使用场景：需要在事件传播到目标元素之前拦截事件。

##### self

功能：确保事件处理程序只在事件直接由元素自身触发时运行，而不是由子元素或其他后代元素触发。

使用场景：避免子元素的事件冒泡导致的干扰，确保事件只在目标元素上触发。

##### once

功能：确保事件处理程序只运行一次，在事件第一次触发后自动移除处理程序。

使用场景：避免事件处理程序重复执行。

##### passive

功能：以模式添加事件监听器，标识该函数永远不会调用`event.preventDefault()，以改善滚动性能。（事件默认行为立即执行，不用等待回调函数结束在执行）

使用场景：滚动事件等性能敏感的场景，允许浏览器优化事件处理。

#### 二、其他事件修饰符（Vue 3.x引入）

1. **.left**
   - 功能：只当点击鼠标左键时触发。
2. **.right**
   - 功能：只当点击鼠标右键时触发。
3. **.middle**
   - 功能：只当点击鼠标中键时触发。
4. **.exact**
   - 功能：控制其他修饰符一起使用时，精确匹配修饰符。

#### 三、修饰符的链式使用

Vue事件修饰符支持链式书写，即可以同时使用多个修饰符。需要注意的是，链式修饰符的调用顺序会影响事件处理的行为。例如：

在这个例子中，点击链接时，会先阻止事件冒泡（`.stop`），然后阻止默认行为（`.prevent`）。

#### 四、使用技巧

1. **深入理解事件模型**：熟悉事件捕获和冒泡阶段，选择合适的修饰符。
2. **结合使用修饰符**：根据具体需求组合使用多个修饰符，实现复杂的事件处理逻辑。
3. **性能优化**：合理使用`.passive`修饰符，提升滚动等高频事件的性能。

####  2：使用事件修饰符

Vue.js 提供了一些事件修饰符来简化键盘事件的监听。例如，`.enter` 修饰符可以用来监听回车键。

在这个示例中，当用户按下回车键时，会触发 `handleEnter` 方法。

####  3：自定义按键处理

如果你需要监听特定的按键（不是 Vue.js 提供的修饰符），你可以检查事件对象的 `key` 属性。

在这个示例中，当用户按下 'a' 或 'A' 键时，会触发 `handleCustomKey` 方法，并在控制台中打印出相应的信息。

####  4：组合键处理

你也可以处理组合键，例如 `Ctrl + S`。

在这个示例中，当用户按下 `Ctrl + S` 时，会触发 `handleCtrlS` 方法，并在控制台中打印出相应的信息。

#### 例子

```
<!-- 
       1.vue中常用的按键别名：
        回车：enter
        删除：delete（删除和退格键）
        空格：space
        退出：esc
        换行：tab（特殊 配合keydown使用）
        上：up
        下：down
        左：left
        右：right
       2.Vue未提供别名的按键，可以使用按键原始的key值去绑定，但要注意转为kebab-case（短横线命名）
       3.系统修饰键（用法特殊）：CTRL alt shift meta
         （1）配合keyup使用：按下修饰键同时，按下其他键，然后释放其他键，事件才被触发
         （2）配合keydown使用：正常触发
        4.也可以使用keycode去指定具体的按键（已经废弃，不推荐）
        5.Vue.config.keyCodes.自定义键名 = 键码 ，可以去指定按键别名        
-->
```

## 计算属性

Vue.js 的计算属性（computed properties）是 Vue 组件中的一种特殊属性，它基于它们的依赖进行缓存，并且只有当相关依赖发生改变时才会重新计算。这使得计算属性非常适合执行复杂的数据处理逻辑，同时保持高效的性能。

### 计算属性的特点

1. **缓存**：计算属性是基于它们的依赖进行缓存的。这意味着只要依赖没有改变，多次访问计算属性会立即返回之前的计算结果，而不会重新执行计算函数。
2. **简洁**：你可以将复杂的逻辑放在计算属性中，然后在模板中像绑定普通属性一样绑定计算属性。这有助于保持模板的简洁和可读性。
3. **依赖追踪**：Vue 会自动追踪计算属性依赖的数据属性。当这些依赖发生变化时，计算属性会自动重新计算。
4. **方法 vs. 计算属性**：虽然计算属性和方法（methods）在模板中看起来类似（都是通过 `{{ }}` 来调用），但计算属性是基于它们的依赖进行缓存的，而方法则会每次调用时都执行函数。因此，对于需要频繁访问的属性，使用计算属性通常比方法更高效。

### 使用计算属性

在 Vue 组件中，你可以通过 `computed` 选项来定义计算属性：

在上面的例子中，`reversedMessage` 是一个计算属性，它返回 `message` 属性的反转字符串。由于它是基于 `message` 的，因此只要 `message` 没有改变，无论 `reversedMessage` 被访问多少次，它都不会重新计算。

### 计算属性的 setter

默认情况下，计算属性只有 getter 函数。但你也可以提供一个 setter 函数，当计算属性被赋值时，setter 函数会被调用：

在这个例子中，`fullName` 计算属性不仅有一个 getter 函数来返回 `firstName` 和 `lastName` 的组合，还有一个 setter 函数来根据新值更新 `firstName` 和 `lastName`。

### 实例

```
<!--    
       计算属性：
            1.定义：要用的属性不存在，要通过已有的属性计算得来
            2.原理：底层使用了OBjcet.defineproperty方法提供的getter和setter
            3.get函数什么时候执行：
                （1）初次读取时执行
                （2）当依赖的数据发生变化时
            4.优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便
            5.备注：
                （1）计算属性最终会出现在vm上，直接读取即可
                （2）如果计算属性要被修改，那必须写set函数响应修改，且set中要引起计算属性依赖的数据发生变化            
-->
```

## 监视属性

在 Vue.js 中，监视属性（watchers）是一种用于观察和响应 Vue 实例上数据变化的机制。通过定义 watcher，你可以在某个数据属性发生变化时执行特定的逻辑。这对于需要在数据变化时执行副作用（side effects）的场景特别有用。

### 基本用法

你可以在 Vue 组件的 `watch` 选项中定义 watcher。

在这个例子中，我们监视了 `question` 属性。每当 `question` 发生变化时，都会调用 `question` 对应的函数，该函数接收两个参数：新值和旧值。

### 深度监视

如果你需要监视一个对象的内部变化（即深度监视），可以使用 `deep` 选项：

在这个例子中，如果 `userProfile` 对象中的 `name` 或 `age` 发生变化，watcher 都会被触发。

**例子2**

```
<!-- 
        深度监测：
            （1）Vue中的watch默认不监测对象内部值的改变
            （2）配置deep：true可以监测对象内部的改变
        备注：
            （1）vue自身可以监测对象内部值的改变，但是vue提供的watch默认不可以
            （2）使用watch时根据具体的结构，决定是否采用深度监测
-->
```

### 立即执行

默认情况下，watcher 会在数据变化之后触发。如果你想在绑定时立即执行一次该 watcher，可以使用 `immediate` 选项：

在这个例子中，当 Vue 实例被创建时，`question` 的 watcher 会立即执行一次。

### 监视计算属性

你也可以监视计算属性，不过通常情况下，计算属性已经足够处理大多数依赖逻辑，因此监视计算属性的需求相对较少。

### 停止监视

在某些情况下，你可能需要在组件销毁前手动停止某个 watcher。你可以使用 `vm.$watch` 返回的解除监视函数：

### 总结

Vue.js 的 watcher 提供了一种灵活的方式来响应数据变化，允许你执行复杂的逻辑和副作用。通过合理配置 `deep` 和 `immediate` 选项，你可以控制 watcher 的行为，以满足不同的需求。

### 例子


```javascript
<!--
         监视属性watch：
            1.当监视的属性发生变化时，回调函数会自动调用，进行相关操作。
            2.监视的属性必须存在，才能进行监视
            3.监视的两种写法：
                （1）new VUe时传入watch配置
                （2）通过vm.$watch()监视
--!>
```

### computed和watch的区别：

computed和watch是Vue.js中两种常用的响应式数据处理方式，它们之间存在以下区别：

#### 一、定义与用途

##### computed（计算属性）

定义：Vue.js提供的一种特性，用于声明式地计算基于其他数据的值。

用途：主要用于根据依赖的数据动态计算值，并返回一个新的值。

##### watch（侦听器）

定义：一个观察动作，可以侦听指定名称属性值（data/computed）的变化。

用途：主要用于监听数据的变化，并在数据变化时执行相应的回调函数。

#### 二、返回值与依赖

##### computed

返回值：有返回值，计算属性会根据其依赖的数据进行计算，并返回结果。 依赖：依赖函数里面提到的属性，并生成一个新的属性。当依赖的属性发生变化时，计算属性会重新计算。

##### watch

返回值：监听的函数不需要返回值。依赖：主动监听某一个属性的变化，当被监听的属性发生变化时，执行回调函数。

#### 三、缓存机制

##### computed 

缓存性：支持缓存。计算属性的结果会被缓存，只有当其依赖的数据发生变化时，才会重新计算。这可以避免不必要的性能开销。

##### watch 

缓存性：不支持缓存。每次监听的数据发生变化时，都会触发相应的回调函数，执行相应的操作。

#### 四、异步操作与支持场景

##### computed

异步：不支持异步操作。当计算属性内有异步操作时，无法监听数据的变化。

支持场景：适用于一个数据受多个数据影响的情况，如购物车商品结算等。

##### watch

异步操作：可以支持异步操作。在回调函数中可以执行异步代码。

支持场景：适用于多个数据受一个数据影响的情况，如搜索框的自动联想等。

#### 五、监听时机与配置

##### computed

监听时机：从一开始就进行监听，当依赖的属性发生变化时，计算属性会自动更新。

##### watch

监听时机：默认不监听第一次加载。如果要监听第一次加载，需要配置`immediate: true`。

配置：可以使用`handler`函数作为回调函数，使用`deep`选项开启深度监听等。

综上所述，computed和watch在Vue.js中各有其独特的用途和优势。开发者应根据具体的需求和场景选择合适的方式来处理响应式数据。

#### 例子：计算属性案例的watch实现

```
<!--    
    computed和watch的区别:
        1.computed可以完成的功能，watch也可以完成
        2.watch能实现的功能，computed不一定能实现。例如：watch可以进行异步操作
    两个重要原则：
       1.所有Vue管理的函数，最好写成普通函数，这样this指向是vm或者组件实例对象
       2.不是vue管理的函数（定时器回调函数，ajax的回调函数，Promise的回调函数），最好写成箭头函数
       这样this指向是vm或者组件实例对象
                  
-->
```

## 绑定样式

在 Vue.js 中，你可以通过多种方式绑定样式（styles）到元素上。这主要包括对象语法和数组语法。

### 对象语法

对象语法允许你通过绑定一个对象来动态地应用多个样式。对象的键是 CSS 属性名，值是该属性的值。

在上面的例子中，`divStyle` 对象中的每个属性都会被应用到 `<div>` 元素上。

### 数组语法

数组语法允许你将多个样式对象绑定到同一个元素上。每个样式对象都会应用到该元素上。

在这个例子中，`baseStyle` 和 `additionalStyle` 对象中的样式都会被应用到 `<div>` 元素上。

### 自动添加前缀

Vue.js 会自动为某些 CSS 属性添加浏览器前缀，例如 `transform`，所以你不需要手动添加 `-webkit-` 或 `-moz-` 等前缀。

### 内联样式 vs. 类名绑定

虽然你可以使用内联样式（即直接绑定样式对象），但有时候使用类名绑定会更清晰和高效，特别是当你需要处理大量样式或希望复用样式时。

### 类名绑定

Vue.js 也支持通过绑定类名来动态应用 CSS 类。你可以使用对象语法或数组语法来绑定类名。

#### 对象语法

#### 数组语法

不过，更简洁的数组语法通常如下：

这样，你可以更好地组织你的类名绑定逻辑。

## 条件渲染

在 Vue.js 中，条件渲染是一种根据条件动态显示或隐藏元素的技术。Vue 提供了两种主要的方法来实现条件渲染：`v-if` 和 `v-show`。

### 1. `v-if`

`v-if` 指令用于根据表达式的真假值来有条件地渲染元素。当表达式的值为 `true` 时，元素会被渲染；当值为 `false` 时，元素及其子元素会被销毁并重新创建。这意味着，如果条件频繁切换，使用 `v-if` 可能会导致性能问题，因为每次切换都会涉及 DOM 的销毁和重建。

### 2. `v-else`

`v-else` 指令可以紧跟在 `v-if` 或 `v-else-if` 元素之后，用于指定当条件不满足时应该渲染的内容。

### 3. `v-else-if`

`v-else-if` 指令用于指定一个条件块，当 `v-if` 的条件不满足且 `v-else-if` 的条件满足时，渲染 `v-else-if` 包裹的内容。

### 4. `v-show`

`v-show` 指令用于根据条件来切换元素的 CSS 属性 `display`。与 `v-if` 不同，`v-show` 只是简单地切换元素的可见性，而不会销毁和重建元素。这意味着，无论条件如何变化，DOM 元素始终保留在 DOM 树中。

### 总结

- 使用 `v-if` 时，如果条件为 `false`，元素及其子元素会被销毁，并在条件变为 `true` 时重新创建。
- 使用 `v-show` 时，元素始终保留在 DOM 树中，只是通过 CSS 属性 `display` 来切换可见性。
- `v-else` 和 `v-else-if` 可以与 `v-if` 一起使用，以处理多个条件。

### 例子：

```
<!-- 
    条件渲染：
       1.v-if：
          写法：（1）v-if="表达式"
                (2)v-else-if="表达式"
                （3）v-else="表达式"
            适用于：切换频率低的场景
            特点：不展示的元素直接移除
            注意：v-if可以和v-else-if、v-else一起使用，但是
            要求结构不能被打断
        2.v-show：
            写法：v-show="表达式"
            适用于：切换频率高的场景
            特点：不展示的元素未被移除，仅仅是使用样式隐藏
        3.备注：使用v-if时，元素可能无法被获取到，而使用v-show一定可以被获取到
-->
```

## 列表渲染

Vue.js 提供了强大的列表渲染功能，使得开发者可以轻松地展示数据列表。以下是一些关于 Vue.js 列表渲染的基本知识和示例：

### 基本用法

在 Vue.js 中，你可以使用 `v-for` 指令来遍历一个数组或对象，并渲染一个元素列表。`v-for` 指令需要绑定到一个数组或对象，并指定一个别名用于在模板中引用每个元素。

#### 注意事项

1. **唯一键值**：在使用 `v-for` 时，建议为每个列表项提供一个唯一的键值（通过 `:key` 属性）。这有助于 Vue 在更新列表时高效地重用和排序元素。
2. **避免使用索引作为键值**：虽然可以使用数组的索引作为键值，但在列表项可能会动态添加、删除或重新排序的情况下，这可能会导致性能问题和渲染错误。因此，最好使用具有唯一性的属性（如 ID）作为键值。
3. **模板语法**：在 `v-for` 中，你可以使用模板语法来访问数组或对象的属性，并将它们绑定到 DOM 元素上。
4. **性能优化**：对于大型列表，Vue 提供了虚拟滚动和分页等性能优化技术，以减少渲染时间和内存占用。

通过掌握这些基本知识和注意事项，你可以使用 Vue.js 的列表渲染功能来创建高效、动态的用户界面。

### key的内部原理

 *面试题：react、vue中的key有什么作用？（key的内部原理）*

​       *1.虚拟DOM中key的作用：*

​         *key是虚拟DOM对象的标识，当数据发生变化时，vue会根据【新数据】生成【新的虚拟DOM】*

​         *随后vue进行【新的虚拟DOM】与【旧的虚拟DOM】进行差异比较*

​       *2.比较规则：*

​         *（1）旧的虚拟DOM中找到了与新的虚拟DOM相同的key：*

​            *1.旧的虚拟DOM中内容没变，直接复用之前的真实DOM*

​            *2.如果虚拟DOM内容改变，则生成新的真实的DOM，替换掉页面之前真实DOM*

​          *(2)旧的虚拟DOM未能找到与新的虚拟DOM相同的key*

​            *1.创建新的真实的DOM，渲染到页面*

​       *3.用index作为key可能引发的问题：*

​           *1.如果对数据进行逆序添加，删除等破坏顺序等操作：*

​            *会产生没用必要的真实DOM更新===>界面无影响，但是效率低*

​           *2.如果结构中含有输入类的DOM*

​             *会产生错误DOM更新===>界面有问题*

​       *4.开发中如何抉择key的使用：*

​          *1.最好使用每一条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值*

​          *2.如果不存在对数据的你需添加等破坏顺序操作，仅用于渲染页面展示*

​          *使用index作为key没问题*

### 列表过滤

在 Vue.js 中，你可以通过计算属性（computed properties）或方法来过滤列表。计算属性通常更适合用于这种场景，因为它们是基于它们的依赖进行缓存的，并且只有在相关依赖发生变化时才会重新计算。

以下是一个简单的例子，展示了如何使用计算属性来过滤一个列表：

#### 示例1

假设你有一个包含用户信息的列表，并且你想根据用户的名字进行过滤。

1. **HTML 模板 (Template)**

1. **Vue 实例 (Vue Instance)**

#### 解释

1. 数据 (Data)

   - `searchQuery`：用于绑定输入框的值，作为过滤条件。
   - `users`：包含用户信息的列表。

2. 计算属性 (Computed Property)

   - `filteredUsers`：根据 `searchQuery` 过滤 `users` 列表。使用 `toLowerCase()` 方法确保搜索不区分大小写。

   - 在 JavaScript 中，`toLowerCase()` 是一个字符串方法，用于将字符串中的所有字符转换为小写形式。这个方法不会改变原始字符串，而是返回一个新的字符串，其中所有大写字符都被转换成了小写。

   - 在JavaScript中，`includes()` 方法是一个非常重要的数组和字符串方法，用于判断数组是否包含某个指定的值，或者字符串是否包含某个指定的子串。

     ### 数组中的 `includes()` 方法

     对于数组，`includes()` 方法的语法如下：

     ```javascript
     javascript复制代码
     
     array.includes(valueToFind[, fromIndex])
     ```

     - `valueToFind`：必需。需要查找的元素值。
     - `fromIndex`：可选。表示从该索引处开始查找 `valueToFind`。如果为负值，则按升序从 `array.length + fromIndex` 的索引开始搜寻。如果省略该参数，则整个数组都会被搜索。

     如果数组中包含指定的元素值，则返回 `true`，否则返回 `false`。

3. 模板 (Template)

   - 使用 `v-model` 绑定 `searchQuery` 到输入框。
   - 使用 `v-for` 指令遍历 `filteredUsers` 列表，并在列表项中显示用户的名字。

#### 注意事项

- **性能**：计算属性是基于它们的依赖进行缓存的，因此只有在 `searchQuery` 或 `users` 发生变化时才会重新计算。

- **不区分大小写**：示例中使用了 `toLowerCase()` 方法来确保搜索不区分大小写。你可以根据需要调整过滤逻辑。

- **响应式**：Vue 的计算属性是响应式的，因此当 `searchQuery` 或 `users` 发生变化时，`filteredUsers` 会自动更新，视图也会相应更新           

### 列表排序

#### sort方法

在 JavaScript 中，`Array.prototype.sort()` 方法用于对数组的元素进行排序。默认情况下，`sort()` 方法会按照字符编码（UTF-16 代码单元值序列）将数组元素转换为字符串，然后比较它们的 UTF-16 代码单元值序列来进行排序，这会导致非数字元素的排序结果可能不符合预期。

为了对数组进行数字排序或自定义排序，你可以向 `sort()` 方法传递一个比较函数。这个比较函数应该接收两个参数（通常记为 `a` 和 `b`），然后根据以下规则返回：

- 如果应该把第一个参数排在前面，则返回一个小于 0 的值。
- 如果应该把第二个参数排在前面，则返回一个大于 0 的值。
- 如果两个参数相等，则返回 0。

##### 数字排序示例

```javascript
const numbers = [4, 2, 5, 1, 3];
numbers.sort((a, b) => a - b);
console.log(numbers); // 输出: [1, 2, 3, 4, 5]
```

在这个例子中，比较函数 `(a, b) => a - b` 用于确保数组按数字大小进行排序。

##### 字符串排序示例（按字母顺序）

虽然默认情况下 `sort()` 方法会对字符串数组进行排序，但最好还是明确提供一个比较函数以确保跨环境的兼容性。

```javascript
const fruits = ['banana', 'apple', 'cherry'];
fruits.sort((a, b) => {
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
});
console.log(fruits); // 输出: ['apple', 'banana', 'cherry']
```

然而，对于字符串数组，你可以省略比较函数，因为默认行为就是按字母顺序排序（尽管这取决于字符串的 UTF-16 编码）：

```javascript
const fruits = ['banana', 'apple', 'cherry'];
fruits.sort();
console.log(fruits); // 输出: ['apple', 'banana', 'cherry']（在大多数情况下）
```

##### 自定义排序示例

假设你有一个对象数组，并且你想根据对象的某个属性进行排序：

```javascript
const people = [
  { name: 'John', age: 30 },
  { name: 'Jane', age: 25 },
  { name: 'Dave', age: 35 }
];
 
people.sort((a, b) => a.age - b.age);
console.log(people);
// 输出: [{ name: 'Jane', age: 25 }, { name: 'John', age: 30 }, { name: 'Dave', age: 35 }]
```

在这个例子中，我们根据 `age` 属性对 `people` 数组进行了排序。

##### 注意事项

- `sort()` 方法会直接修改原数组，而不是返回一个新数组。
- 如果没有提供比较函数，`sort()` 方法的行为可能因 JavaScript 引擎而异，特别是当数组元素不是简单的字符串时。因此，最好总是提供一个比较函数来确保排序行为的一致性。

### vue数据监测原理

Vue数据监测的原理主要基于其响应式系统，该系统能够追踪数据的变化并自动更新视图。以下是Vue数据监测原理的详细解释：

#### 一、数据劫持

Vue使用数据劫持技术来监测数据的变化。在Vue 2.x中，主要通过`Object.defineProperty()`方法来实现数据劫持。这个方法允许Vue为对象的属性添加getter和setter方法。当这些属性被访问或修改时，Vue可以检测到并作出相应的响应。

在Vue 3.x中，Vue使用了更现代的`Proxy` API来替代`Object.defineProperty()`。`Proxy`可以直接代理整个对象，具有更好的性能和灵活性，尤其是在处理深层次嵌套对象时。

#### 二、依赖收集

Vue的响应式系统还涉及依赖收集的过程。当Vue组件的模板在渲染时，会访问数据对象中的属性。Vue会利用getter方法来追踪这些属性的访问，并将当前的Watcher（观察者对象）添加到该属性的依赖列表中。这个依赖列表存储了所有依赖该属性的Watcher实例。

#### 三、派发更新

当数据对象的属性发生变化时，Vue会利用setter方法来通知所有的Watcher。这些Watcher会订阅数据的变化，并在数据变化时触发相应的更新逻辑。具体来说，Watcher会调用自己的`update`方法，该方法会触发相关的视图更新操作，从而确保视图和数据保持同步。

#### 四、响应式数据绑定

Vue的响应式数据绑定机制是其核心特性之一。通过在Vue实例中定义`data`属性，Vue可以自动检测和响应数据的变化，从而动态更新视图。这种机制非常高效，因为它只会更新实际发生变化的部分，而不是整个页面。

#### 五、计算属性和观察者

除了基本的响应式数据绑定外，Vue还提供了计算属性和观察者来增强数据监测的能力。

- **计算属性**：基于响应式数据计算得出的属性，它们依赖于其他响应式数据，并会在其依赖的数据发生变化时自动重新计算。计算属性在需要复杂数据处理或多次使用相同计算逻辑时非常有用。
- **观察者**：允许开发者对特定的数据变化做出反应，而不是在模板中绑定数据。观察者适用于需要在数据变化时执行异步操作或复杂逻辑的场景。

#### 六、示例代码

以下是一个简单的Vue示例代码，展示了数据监测和自动更新视图的过程：

在这个例子中，当`message`属性的值发生变化时，Vue会自动检测到并更新视图中的`<p>`标签内容。同时，`watch`属性中的回调函数也会被触发，输出新旧值的变化。

综上所述，Vue的数据监测原理是通过数据劫持、依赖收集、派发更新以及响应式数据绑定等机制共同实现的。这些机制使得Vue能够高效地监测数据的变化并自动更新视图，为开发者提供了简洁、高效的开发体验。

#### 七、set的使用

在Vue中，当你直接修改对象或数组的属性时，由于Vue无法检测到这些变化（特别是在Vue 2.x中，Vue 3.x的响应式系统有所改进，但仍然有需要注意的地方），因此你需要使用Vue提供的`Vue.set`方法（在Vue 3中，这个方法被移动到了`reactive`或`ref`对象的上下文中，或者直接使用`app.config.set`，但更常见的是直接修改响应式对象，因为Vue 3的响应式系统更加智能）来确保这些变化能够被检测到并触发视图更新。

##### Vue 2.x 中的 `Vue.set`

在Vue 2.x中，`Vue.set`方法用于向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，以及触发视图更新。它的使用方式如下：

##### Vue 3.x 中的响应式修改

在Vue 3.x中，由于使用了`Proxy`来创建响应式对象，Vue的响应式系统更加智能，能够检测到更多类型的变更。然而，仍然有一些需要注意的地方，特别是在处理嵌套对象或数组时。

对于嵌套对象，如果你想要添加一个新的响应式属性，你可以直接修改对象（如果对象本身是响应式的），Vue 3通常能够检测到这个变化：

但是，如果你想要确保Vue能够检测到数组的变化（比如添加或删除元素），你仍然需要小心操作。虽然Vue 3的响应式数组能够检测到长度的变化和一些方法调用（如`push`、`pop`等），但如果你直接设置数组的索引或修改数组的长度，Vue可能无法检测到这些变化。在这种情况下，你可以使用Vue 3提供的`reactive`对象的`$set`方法（如果存在的话，这取决于你的具体实现和Vue版本，因为Vue 3的API可能会随着版本更新而变化）。不过，在大多数情况下，直接操作响应式数组的方法（如`push`、`splice`等）就足够了。

请注意，Vue 3的组合式API（Composition API）鼓励使用`ref`和`reactive`来创建响应式状态，而不是像Vue 2那样依赖`data`选项。在组合式API中，你通常会直接修改`ref`的`.value`属性或`reactive`对象的属性，Vue会自动检测到这些变化。

#### 八、示例

```
<!-- 
      vue监视数据的原理:
          1.vue会监视data中所有层次的数据
          2.如何监测对象中的数据？
            通过setter实现监测，且要在new Vue时传入要监测的数据
            （1）对象中后追加的数据，vue默认不做相应处理
            （2）如果需要给添加的属性做响应式，请使用如下api
                  Vue.set(target,propertyName/index,value)或
                  vm.$set(target,propertyName/index,value)
          3.如何监测数组中的数据？
            通过包裹数组更新元素的方法实现，本质做了两件事:
            （1）调用原生对应的方法对数组进行更新
            （2）重新解析模板，进而更新页面
          4.在Vue修改数组中的某个元素时一定要用如下方法：
            （1）.使用这些api：push(),pop(),shift(),unshift(),splice(),sort(),reverse()
            （2）.Vue.set()或者vm.$set()       
        注意：
           Vue.set()或者vm.$set()不能给vm或者vm的根对象添加属性
-->
```



##    表单收集

在Vue.js中收集表单数据是一项常见的任务。Vue.js 提供了数据绑定和事件处理机制，使得收集和处理表单数据变得格外简单和高效。以下是一个简单的示例，展示了如何在Vue.js中收集表单数据。

### 1. 创建Vue实例并定义数据模型

首先，你需要创建一个Vue实例，并在其中定义用于存储表单数据的模型（data）。

### 2. 解释代码

- HTML结构

  ：

  - 包含一个表单，表单中的每个输入字段都使用`v-model`指令绑定到Vue实例的`formData`对象上。
  - 表单的`@submit.prevent`事件监听器防止默认的表单提交行为，并调用`handleSubmit`方法。
  - 如果表单已提交（`submitted`为`true`），则显示提交的数据。

- Vue实例

  ：

  - `data`对象包含表单数据模型`formData`，以及用于标记表单是否已提交的`submitted`和存储提交数据的`submittedData`。
  - `methods`对象包含一个`handleSubmit`方法，该方法在表单提交时被调用。它设置`submitted`为`true`，并将表单数据复制到`submittedData`中，同时可以在控制台中打印这些数据。

### 3. 扩展功能

- **表单验证**：在`handleSubmit`方法中添加验证逻辑，确保用户输入了有效的数据。
- **发送数据到服务器**：使用`axios`或`fetch`等HTTP客户端将表单数据发送到后端服务器。
- **重置表单**：添加一个方法用于重置表单，将`formData`重置为初始状态。

### 4. 使用Vue 3

如果你使用的是Vue 3，可以使用Composition API来实现相同的功能：

### 5.示例

```
<!--
          收集表单数据 :
            1.如果<input type="text/">,则v-model收集的是value值，用户输入的就是value值
            2.如果<input type="radio/">,则v-model收集的是value值，且要给标签配置value值
            3.如果<input type="checkbox/">，则
                （1）没有配置input的value属性，那么收集的就是checked（勾选or或者未勾选，是布尔值）
                （2）配置input的value属性:
                        v-model的初始值是非数组,那么收集的是checked（勾选or或者未勾选 布尔值）
                        v-model的初始值是数组,那么收集的就是value组成的数组
            4.备注：v-model的三个属性
              lazy：失去焦点在收集数据
              number：输入字符串转化为数字
              trim：输入首尾空格过滤
-->
```

## 过滤器

在Vue.js中，过滤器（filters）是一种用于文本格式化的功能。它们可以被用于插值表达式（`{{ }}`）和`v-bind`表达式中，对显示的数据进行格式化。不过，需要注意的是，从Vue 3.x开始，过滤器已经被移除，因为Vue团队鼓励使用计算属性（computed properties）或方法（methods）来处理数据的显示逻辑。

### Vue 2.x中的过滤器

在Vue 2.x中，你可以全局或局部地注册过滤器。全局过滤器在整个Vue实例中都可以使用，而局部过滤器只能在注册它的组件中使用。

#### 全局过滤器

#### 局部过滤器

在模板中，使用方法与全局过滤器相同：

### Vue 3.x中的替代方案

由于Vue 3.x不再支持过滤器，你需要使用其他方法来格式化数据。计算属性和方法是最常见的替代方案。

#### 使用计算属性

#### 使用方法

然而，在模板中直接使用方法可能会导致性能问题，因为每当组件重新渲染时，方法都会被调用。相比之下，计算属性是基于它们的依赖进行缓存的，只有当依赖发生变化时才会重新计算。因此，对于基于数据变化的数据格式化，计算属性通常是更好的选择。

## vue内置指令

Vue.js是一个渐进式JavaScript框架，广泛应用于前端开发中。Vue提供了丰富的内置指令（Directives），用于在模板中实现各种功能。以下是Vue的主要内置指令及其说明：

1. **v-bind**：用于动态地绑定一个或多个属性，或者组件prop到表达式。可以简写为“:”。
2. **v-model**：在表单控件元素上创建双向数据绑定。它会根据控件的类型自动选取正确的方法来更新元素。
3. **v-if**：根据表达式的值的真假条件性地渲染元素。当表达式的值为true时，渲染元素及其内容；为false时，移除元素及其内容。
4. **v-else**：必须紧跟在v-if元素或者v-else-if元素之后，否则它将不会被识别。它表示v-if条件不满足时显示的内容。
5. **v-else-if**：连续使用于v-if和v-else之后，用于多条件判断。
6. **v-show**：根据表达式的值的真假切换元素的显示状态。与v-if不同，v-show只是简单地切换元素的CSS属性display。这意味着元素始终在DOM中，只是不可见而已。
7. **v-for**：基于源数据多次渲染元素或模板块。它通常用于渲染列表或表格数据。
8. **v-on**：绑定事件监听器，用来监听DOM事件。可以简写为“@”。
9. **v-html**：更新元素的innerHTML。内容被视作HTML，并会被渲染为真正的HTML元素。但使用v-html渲染的HTML内容并不在Vue的响应式系统之内，同时需要注意防止XSS攻击。
10. **v-pre**：跳过这个元素和它的子元素的编译过程。可以用来显示原始Mustache标签。
11. **v-cloak**：这个指令保持在元素上直到关联实例结束编译。和CSS规则``一起用时，这个指令可以隐藏未编译的Mustache标签直到实例准备完毕。
12. **v-once**：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化性能。
13. **v-slot**：用于具名插槽和作用域插槽。在Vue 2.6.0+中引入，允许开发者定义插槽的名称和作用域。

这些指令是Vue模板语法的一部分，用于在DOM元素上添加特定的行为。通过使用这些指令，开发者可以方便地操作DOM元素，实现数据绑定、事件处理、条件渲染等功能。

## 补充：xss攻击：

XSS攻击，即跨站脚本攻击（Cross Site Scripting），是一种常见的网络安全漏洞，它允许攻击者将恶意脚本代码注入到正常的网页中。当用户访问该网页时，恶意脚本代码将在用户的浏览器中执行，从而获取用户的敏感信息、篡改网页内容、进行恶意操作等。以下是对XSS攻击的详细介绍：

### 一、XSS攻击的原理

XSS攻击利用了Web应用程序对用户输入的数据没有进行充分的过滤和验证的漏洞。当应用程序没有对用户输入的数据进行适当的处理时，攻击者可以注入恶意脚本，如HTML或JavaScript代码。这些恶意脚本随着用户的访问而被执行，从而达到攻击的目的。

### 二、XSS攻击的类型

XSS攻击主要分为以下几种类型：

1. **反射型XSS（非持久型XSS）**：攻击者通过特定的方式诱惑受害者访问一个包含恶意代码的URL。当受害者点击这个恶意链接时，注入脚本被传输到目标服务器上，然后服务器将注入脚本反射回受害者的浏览器，浏览器解析并执行这段恶意脚本。这种类型的攻击通常用于窃取用户的Cookie或者其他敏感信息。
2. **存储型XSS（持久型XSS）**：攻击者将恶意代码永久地嵌入到一个页面中，当用户访问这个页面时，恶意脚本会被触发执行。这种类型的攻击较为危险，因为它可以长期地影响用户，并且影响范围更广，可以影响到所有访问该页面的用户。
3. **DOM型XSS**：通过修改页面的DOM结构来执行恶意脚本。这种类型的攻击不涉及服务器端的数据交互，是基于客户端JavaScript代码的不当处理。攻击者可以利用DOM操作在客户端执行恶意脚本，从而窃取用户信息或进行其他恶意操作。

### 三、XSS攻击的危害

XSS攻击的危害极大，主要包括以下几个方面：

1. **窃取用户信息**：攻击者可以窃取用户的敏感信息，如Cookies、session IDs等，进而模拟用户的身份执行操作。
2. **劫持用户会话**：攻击者可以劫持用户的会话，控制用户的浏览器进行恶意操作。
3. **进行钓鱼攻击**：攻击者可以诱导用户输入敏感信息，如银行账户密码、信用卡信息等。
4. **恶意重定向**：攻击者可以将用户重定向到恶意网站，进一步实施其他攻击。
5. **破坏页面结构**：攻击者可以破坏页面的正常结构，显示虚假信息，误导用户。

### 四、XSS攻击的防御措施

为了防御XSS攻击，可以采取以下措施：

1. **输入验证和过滤**：对用户输入的数据进行严格的验证和过滤，确保只允许特定的字符和格式。可以使用白名单策略，限制可以接受的输入类型和格式。
2. **输出编码**：在将用户输入显示为网页内容之前，对特殊字符进行适当的编码，以避免它们在浏览器中解释为代码。常用的编码方法包括HTML实体编码或JavaScript原始字符串。
3. **使用安全的HTTP头部**：设置Content-Security-Policy（CSP）头部，限制外部资源的加载，减少恶意脚本被执行的机会。同时，使用HttpOnly标记的Cookie，防止JavaScript访问Cookie中的内容。
4. **内容安全策略（CSP）**：CSP是一种安全机制，用于减少跨站脚本攻击（XSS）的风险。它可以强制实施内容来源限制，防止恶意内容在受害者的浏览器中执行。
5. **跨站请求伪造防护**：检查所有来自用户的表单数据、cookie或会话数据，以防止跨站请求伪造（CSRF）攻击和XSS攻击。确保所有表单都包含适当的CSRF保护措施。
6. **定期更新和打补丁**：保持网站和应用程序的最新版本，并修复所有安全漏洞，以确保其安全性。
7. **使用Web应用防火墙（WAF）**：WAF能够自动识别和阻止XSS攻击，并提供灵活的配置选项，允许用户根据自己的网站特性定制安全规则。
8. **安全培训和意识提升**：对开发人员进行安全编码的培训，提高他们的安全意识。同时，定期进行代码审查和安全测试，以识别潜在的安全漏洞。

综上所述，XSS攻击是一种常见的网络安全威胁，但通过采取适当的防御措施，可以有效地降低其风险。

## 自定义指令

在 Vue.js 中，自定义指令是一种用于在 DOM 元素上直接操作底层行为的工具。通过自定义指令，你可以对 DOM 元素进行插入、更新、绑定和解绑等生命周期钩子函数的控制。以下是如何创建和使用自定义指令的基本步骤：

### 1. 注册自定义指令

你可以在全局或局部注册自定义指令。

#### 全局注册

在 Vue 应用实例化之前，你可以使用 `Vue.directive` 方法来全局注册一个自定义指令。

#### 局部注册

你也可以在组件中通过 `directives` 选项来局部注册一个自定义指令。

### 2. 使用自定义指令

在模板中，你可以通过 `v-` 前缀加上指令名称来使用自定义指令。

### 3. 指令钩子函数

一个指令定义对象可以包含以下钩子函数：

- `bind`：只调用一次，指令第一次绑定到元素时调用。
- `inserted`：被绑定元素插入父节点时调用（父节点存在即可调用）。
- `update`：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。
- `componentUpdated`：指令所在组件的 VNode 及其子 VNode 全部更新后调用。
- `unbind`：只调用一次，指令与元素解绑时调用。

### 示例：自定义指令实现一个点击次数计数器

下面是一个简单的示例，实现一个自定义指令，用于记录点击次数并显示在元素旁边。

#### 注册指令

#### 使用指令

在这个示例中，每次点击按钮时，点击次数都会显示在按钮的右上角。

### 总结

自定义指令在 Vue.js 中提供了一种灵活的方式来操作 DOM 元素，可以用于实现一些复杂的交互效果。通过钩子函数，你可以控制指令在不同生命周期阶段的行为，从而实现对 DOM 元素的精确控制。

### 示例

```
<!-- 
           自定义指令：
                 一、定义语法：
                     （1）局部指令：
                          new Vue({                                 new Vue({                                
                             directives:{指令名:配置对象}      或             directives:{指令名：回调函数}    
                          })  
                       （2）全局指令：
                          Vue.directive(指令名,配置对象)       或    Vue.directives(指令名,回调函数)                                          }) 
                二、配置对象中常见三个回调：
                    （1）bind: 指令与元素成功绑定时调用
                    （2）inserted：指令所在元素被插入页面时调用
                    （3）update：指令所在模板被重新解析时调用
                三、备注：
                    1.指令定义时不加v-，但使用时要加v-
                    2.指令如果时多个单词，要使用kebab-case的命名方式，不要用驼峰命名法                                                                  
-->
```

## 生命周期

Vue生命周期是指Vue组件从创建到销毁的整个过程。在这个过程中，组件会经历一系列的阶段，每个阶段都有其特定的生命周期钩子函数，这些钩子函数允许开发者在不同的阶段插入自定义逻辑。以下是Vue 2和Vue 3的生命周期钩子函数的详细对比和介绍：

### Vue 2生命周期

1. **创建阶段**
   - **beforeCreate**：实例被创建之前调用，此时组件的数据和事件尚未设置，不能访问data和computed属性。
   - **created**：实例被创建后调用，此时数据观测已完成，可以访问data、computed和methods，适合进行数据初始化或API调用。
2. **挂载阶段**
   - **beforeMount**：组件即将挂载到DOM上，render函数尚未被调用，这是最后一次更改数据的机会。
   - **mounted**：组件挂载完成后调用，此时所有的DOM元素均可用，适合进行DOM操作、启动定时器或请求数据。
3. **更新阶段**
   - **beforeUpdate**：组件的数据发生变化，但虚拟DOM尚未更新，此时可以访问到更新前的状态，适合进行一些状态检查或准备工作。
   - **updated**：数据更新导致虚拟DOM重新渲染和更新后被调用，此时DOM已经更新，可以进行依赖于最新DOM的操作。
4. **销毁阶段**
   - **beforeDestroy**：组件销毁之前调用，此时可以进行清理工作，如取消订阅、清除定时器等。
   - **destroyed**：组件销毁后调用，所有的事件监听器和子实例均已被移除，适合进行最后的清理。

此外，Vue 2中，如果组件被`<keep-alive>`包裹，则会在切换时不会进行销毁，而是缓存到内存中，并执行`deactivated`钩子函数。当命中缓存渲染后，会执行`activated`钩子函数。

### Vue 3生命周期（组合式API）

1. **创建阶段**
   - **setup**：在组件实例创建之前调用，是组合式API的入口。在`setup`中，无法访问`this`，所有属性和方法都需直接返回。
2. **挂载阶段**
   - **onBeforeMount**：在组件挂载之前调用，适合做准备工作。此时，组件还未被插入到DOM中，适用于初始化一些不依赖于DOM渲染的操作。
   - **onMounted**：组件挂载后调用，适合进行DOM操作。此时，组件已被插入到DOM中，可以进行对DOM的操作或进行网络请求。
3. **更新阶段**
   - **onBeforeUpdate**：在组件数据更新之前调用，此时组件尚未重新渲染，适合进行一些状态检查或准备工作。
   - **onUpdated**：数据更新完成后调用，此时组件已经重新渲染完成，适合在组件更新完成后进行操作，如处理与更新后的DOM状态相关的逻辑。
4. **卸载阶段**
   - **onBeforeUnmount**：在组件卸载之前调用，适合进行清理工作，如取消事件监听或释放资源。此时，组件仍然存在于DOM中。
   - **onUnmounted**：组件卸载完成后调用，适合执行一些收尾工作，如记录日志或清理外部库的实例。此时，组件已经从DOM中被移除。

此外，Vue 3还引入了`onActivated`和`onDeactivated`钩子函数，用于处理被`<keep-alive>`缓存的组件的激活和停用状态。

### 父子组件生命周期钩子函数执行顺序

在Vue中，父组件和子组件的生命周期钩子函数执行顺序大致如下：

1. **加载渲染过程**：父组件`beforeCreate` → 父组件`created` → 父组件`beforeMount` → 子组件`beforeCreate` → 子组件`created` → 子组件`beforeMount` → 子组件`mounted` → 父组件`mounted`
2. **更新过程**：父组件`beforeUpdate` → 子组件`beforeUpdate` → 子组件`updated` → 父组件`updated`
3. **销毁过程**：父组件`beforeDestroy` → 子组件`beforeDestroy` → 子组件`destroyed` → 父组件`destroyed`

这个顺序确保了子组件总是先于父组件进行创建、挂载和卸载，同时在更新阶段，子组件会先于父组件进行更新。

总的来说，理解Vue生命周期有助于开发者更好地管理组件的状态和行为，使得组件更加健壮和可维护。

### 示例

```
<!-- 
          生命周期：
             1.又名生命周期函数、生命周期回调函数、生命周期钩子
             2.是什么：vue在关键时刻为我们调用的一些特殊名称的函数
             3.生命周期函数的名字不可以更改，但是函数的具体内容是程序员根据需求写的
             4.生命周期函数中的this指向是vm或者组件实例对象
-->
```

### 总结

```
<!-- 
          生命周期总结：
            1.常用生命周期钩子：
               （1）mounted：发送axios请求，启动定时器，绑定自定义事件，订阅消息等【初始化操作】
               （2）beforeDestroy：清除定时器，解除自定义事件，取消消息订阅等
            2.关于销毁Vue实例：
                （1）销毁后借助vue开发工具看不到任何消息
                （2）销毁后自定义的时间会失效，但是原声DOM事件依然有效
                （3）一般不会在beforeDestroy操作数据，因为即使操作数据，也不会触发更新流程
-->
```

